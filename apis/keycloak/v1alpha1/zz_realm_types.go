/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AuthObservation struct {
}

type AuthParameters struct {

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	Username *string `json:"username" tf:"username,omitempty"`
}

type BruteForceDetectionObservation struct {
}

type BruteForceDetectionParameters struct {

	// +kubebuilder:validation:Optional
	FailureResetTimeSeconds *float64 `json:"failureResetTimeSeconds,omitempty" tf:"failure_reset_time_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	MaxFailureWaitSeconds *float64 `json:"maxFailureWaitSeconds,omitempty" tf:"max_failure_wait_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	MaxLoginFailures *float64 `json:"maxLoginFailures,omitempty" tf:"max_login_failures,omitempty"`

	// +kubebuilder:validation:Optional
	MinimumQuickLoginWaitSeconds *float64 `json:"minimumQuickLoginWaitSeconds,omitempty" tf:"minimum_quick_login_wait_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	PermanentLockout *bool `json:"permanentLockout,omitempty" tf:"permanent_lockout,omitempty"`

	// +kubebuilder:validation:Optional
	QuickLoginCheckMilliSeconds *float64 `json:"quickLoginCheckMilliSeconds,omitempty" tf:"quick_login_check_milli_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	WaitIncrementSeconds *float64 `json:"waitIncrementSeconds,omitempty" tf:"wait_increment_seconds,omitempty"`
}

type HeadersObservation struct {
}

type HeadersParameters struct {

	// +kubebuilder:validation:Optional
	ContentSecurityPolicy *string `json:"contentSecurityPolicy,omitempty" tf:"content_security_policy,omitempty"`

	// +kubebuilder:validation:Optional
	ContentSecurityPolicyReportOnly *string `json:"contentSecurityPolicyReportOnly,omitempty" tf:"content_security_policy_report_only,omitempty"`

	// +kubebuilder:validation:Optional
	StrictTransportSecurity *string `json:"strictTransportSecurity,omitempty" tf:"strict_transport_security,omitempty"`

	// +kubebuilder:validation:Optional
	XContentTypeOptions *string `json:"xContentTypeOptions,omitempty" tf:"x_content_type_options,omitempty"`

	// +kubebuilder:validation:Optional
	XFrameOptions *string `json:"xFrameOptions,omitempty" tf:"x_frame_options,omitempty"`

	// +kubebuilder:validation:Optional
	XRobotsTag *string `json:"xRobotsTag,omitempty" tf:"x_robots_tag,omitempty"`

	// +kubebuilder:validation:Optional
	XXSSProtection *string `json:"xXssProtection,omitempty" tf:"x_xss_protection,omitempty"`
}

type InternationalizationObservation struct {
}

type InternationalizationParameters struct {

	// +kubebuilder:validation:Required
	DefaultLocale *string `json:"defaultLocale" tf:"default_locale,omitempty"`

	// +kubebuilder:validation:Required
	SupportedLocales []*string `json:"supportedLocales" tf:"supported_locales,omitempty"`
}

type OtpPolicyObservation struct {
}

type OtpPolicyParameters struct {

	// What hashing algorithm should be used to generate the OTP.
	// +kubebuilder:validation:Optional
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// +kubebuilder:validation:Optional
	Digits *float64 `json:"digits,omitempty" tf:"digits,omitempty"`

	// +kubebuilder:validation:Optional
	InitialCounter *float64 `json:"initialCounter,omitempty" tf:"initial_counter,omitempty"`

	// +kubebuilder:validation:Optional
	LookAheadWindow *float64 `json:"lookAheadWindow,omitempty" tf:"look_ahead_window,omitempty"`

	// +kubebuilder:validation:Optional
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// OTP Type, totp for Time-Based One Time Password or hotp for counter base one time password
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type RealmObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	InternalID *string `json:"internalId,omitempty" tf:"internal_id,omitempty"`
}

type RealmParameters struct {

	// +kubebuilder:validation:Optional
	AccessCodeLifespan *string `json:"accessCodeLifespan,omitempty" tf:"access_code_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	AccessCodeLifespanLogin *string `json:"accessCodeLifespanLogin,omitempty" tf:"access_code_lifespan_login,omitempty"`

	// +kubebuilder:validation:Optional
	AccessCodeLifespanUserAction *string `json:"accessCodeLifespanUserAction,omitempty" tf:"access_code_lifespan_user_action,omitempty"`

	// +kubebuilder:validation:Optional
	AccessTokenLifespan *string `json:"accessTokenLifespan,omitempty" tf:"access_token_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	AccessTokenLifespanForImplicitFlow *string `json:"accessTokenLifespanForImplicitFlow,omitempty" tf:"access_token_lifespan_for_implicit_flow,omitempty"`

	// +kubebuilder:validation:Optional
	AccountTheme *string `json:"accountTheme,omitempty" tf:"account_theme,omitempty"`

	// +kubebuilder:validation:Optional
	ActionTokenGeneratedByAdminLifespan *string `json:"actionTokenGeneratedByAdminLifespan,omitempty" tf:"action_token_generated_by_admin_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	ActionTokenGeneratedByUserLifespan *string `json:"actionTokenGeneratedByUserLifespan,omitempty" tf:"action_token_generated_by_user_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	AdminTheme *string `json:"adminTheme,omitempty" tf:"admin_theme,omitempty"`

	// +kubebuilder:validation:Optional
	Attributes map[string]*string `json:"attributes,omitempty" tf:"attributes,omitempty"`

	// Which flow should be used for BrowserFlow
	// +kubebuilder:validation:Optional
	BrowserFlow *string `json:"browserFlow,omitempty" tf:"browser_flow,omitempty"`

	// Which flow should be used for ClientAuthenticationFlow
	// +kubebuilder:validation:Optional
	ClientAuthenticationFlow *string `json:"clientAuthenticationFlow,omitempty" tf:"client_authentication_flow,omitempty"`

	// +kubebuilder:validation:Optional
	ClientSessionIdleTimeout *string `json:"clientSessionIdleTimeout,omitempty" tf:"client_session_idle_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	ClientSessionMaxLifespan *string `json:"clientSessionMaxLifespan,omitempty" tf:"client_session_max_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultDefaultClientScopes []*string `json:"defaultDefaultClientScopes,omitempty" tf:"default_default_client_scopes,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultOptionalClientScopes []*string `json:"defaultOptionalClientScopes,omitempty" tf:"default_optional_client_scopes,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultSignatureAlgorithm *string `json:"defaultSignatureAlgorithm,omitempty" tf:"default_signature_algorithm,omitempty"`

	// Which flow should be used for DirectGrantFlow
	// +kubebuilder:validation:Optional
	DirectGrantFlow *string `json:"directGrantFlow,omitempty" tf:"direct_grant_flow,omitempty"`

	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// +kubebuilder:validation:Optional
	DisplayNameHTML *string `json:"displayNameHtml,omitempty" tf:"display_name_html,omitempty"`

	// Which flow should be used for DockerAuthenticationFlow
	// +kubebuilder:validation:Optional
	DockerAuthenticationFlow *string `json:"dockerAuthenticationFlow,omitempty" tf:"docker_authentication_flow,omitempty"`

	// +kubebuilder:validation:Optional
	DuplicateEmailsAllowed *bool `json:"duplicateEmailsAllowed,omitempty" tf:"duplicate_emails_allowed,omitempty"`

	// +kubebuilder:validation:Optional
	EditUsernameAllowed *bool `json:"editUsernameAllowed,omitempty" tf:"edit_username_allowed,omitempty"`

	// +kubebuilder:validation:Optional
	EmailTheme *string `json:"emailTheme,omitempty" tf:"email_theme,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	Internationalization []InternationalizationParameters `json:"internationalization,omitempty" tf:"internationalization,omitempty"`

	// +kubebuilder:validation:Optional
	LoginTheme *string `json:"loginTheme,omitempty" tf:"login_theme,omitempty"`

	// +kubebuilder:validation:Optional
	LoginWithEmailAllowed *bool `json:"loginWithEmailAllowed,omitempty" tf:"login_with_email_allowed,omitempty"`

	// +kubebuilder:validation:Optional
	Oauth2DeviceCodeLifespan *string `json:"oauth2DeviceCodeLifespan,omitempty" tf:"oauth2_device_code_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	Oauth2DevicePollingInterval *float64 `json:"oauth2DevicePollingInterval,omitempty" tf:"oauth2_device_polling_interval,omitempty"`

	// +kubebuilder:validation:Optional
	OfflineSessionIdleTimeout *string `json:"offlineSessionIdleTimeout,omitempty" tf:"offline_session_idle_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	OfflineSessionMaxLifespan *string `json:"offlineSessionMaxLifespan,omitempty" tf:"offline_session_max_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	OfflineSessionMaxLifespanEnabled *bool `json:"offlineSessionMaxLifespanEnabled,omitempty" tf:"offline_session_max_lifespan_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	OtpPolicy []OtpPolicyParameters `json:"otpPolicy,omitempty" tf:"otp_policy,omitempty"`

	// String that represents the passwordPolicies that are in place. Each policy is separated with " and ". Supported policies can be found in the server-info providers page. example: "upperCase(1) and length(8) and forceExpiredPasswordChange(365) and notUsername(undefined)"
	// +kubebuilder:validation:Optional
	PasswordPolicy *string `json:"passwordPolicy,omitempty" tf:"password_policy,omitempty"`

	// +kubebuilder:validation:Required
	Realm *string `json:"realm" tf:"realm,omitempty"`

	// +kubebuilder:validation:Optional
	RefreshTokenMaxReuse *float64 `json:"refreshTokenMaxReuse,omitempty" tf:"refresh_token_max_reuse,omitempty"`

	// +kubebuilder:validation:Optional
	RegistrationAllowed *bool `json:"registrationAllowed,omitempty" tf:"registration_allowed,omitempty"`

	// +kubebuilder:validation:Optional
	RegistrationEmailAsUsername *bool `json:"registrationEmailAsUsername,omitempty" tf:"registration_email_as_username,omitempty"`

	// Which flow should be used for RegistrationFlow
	// +kubebuilder:validation:Optional
	RegistrationFlow *string `json:"registrationFlow,omitempty" tf:"registration_flow,omitempty"`

	// +kubebuilder:validation:Optional
	RememberMe *bool `json:"rememberMe,omitempty" tf:"remember_me,omitempty"`

	// Which flow should be used for ResetCredentialsFlow
	// +kubebuilder:validation:Optional
	ResetCredentialsFlow *string `json:"resetCredentialsFlow,omitempty" tf:"reset_credentials_flow,omitempty"`

	// +kubebuilder:validation:Optional
	ResetPasswordAllowed *bool `json:"resetPasswordAllowed,omitempty" tf:"reset_password_allowed,omitempty"`

	// +kubebuilder:validation:Optional
	RevokeRefreshToken *bool `json:"revokeRefreshToken,omitempty" tf:"revoke_refresh_token,omitempty"`

	// +kubebuilder:validation:Optional
	SMTPServer []SMTPServerParameters `json:"smtpServer,omitempty" tf:"smtp_server,omitempty"`

	// SSL Required: Values can be 'none', 'external' or 'all'.
	// +kubebuilder:validation:Optional
	SSLRequired *string `json:"sslRequired,omitempty" tf:"ssl_required,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityDefenses []SecurityDefensesParameters `json:"securityDefenses,omitempty" tf:"security_defenses,omitempty"`

	// +kubebuilder:validation:Optional
	SsoSessionIdleTimeout *string `json:"ssoSessionIdleTimeout,omitempty" tf:"sso_session_idle_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	SsoSessionIdleTimeoutRememberMe *string `json:"ssoSessionIdleTimeoutRememberMe,omitempty" tf:"sso_session_idle_timeout_remember_me,omitempty"`

	// +kubebuilder:validation:Optional
	SsoSessionMaxLifespan *string `json:"ssoSessionMaxLifespan,omitempty" tf:"sso_session_max_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	SsoSessionMaxLifespanRememberMe *string `json:"ssoSessionMaxLifespanRememberMe,omitempty" tf:"sso_session_max_lifespan_remember_me,omitempty"`

	// +kubebuilder:validation:Optional
	UserManagedAccess *bool `json:"userManagedAccess,omitempty" tf:"user_managed_access,omitempty"`

	// +kubebuilder:validation:Optional
	VerifyEmail *bool `json:"verifyEmail,omitempty" tf:"verify_email,omitempty"`

	// +kubebuilder:validation:Optional
	WebAuthnPasswordlessPolicy []WebAuthnPasswordlessPolicyParameters `json:"webAuthnPasswordlessPolicy,omitempty" tf:"web_authn_passwordless_policy,omitempty"`

	// +kubebuilder:validation:Optional
	WebAuthnPolicy []WebAuthnPolicyParameters `json:"webAuthnPolicy,omitempty" tf:"web_authn_policy,omitempty"`
}

type SMTPServerObservation struct {
}

type SMTPServerParameters struct {

	// +kubebuilder:validation:Optional
	Auth []AuthParameters `json:"auth,omitempty" tf:"auth,omitempty"`

	// +kubebuilder:validation:Optional
	EnvelopeFrom *string `json:"envelopeFrom,omitempty" tf:"envelope_from,omitempty"`

	// +kubebuilder:validation:Required
	From *string `json:"from" tf:"from,omitempty"`

	// +kubebuilder:validation:Optional
	FromDisplayName *string `json:"fromDisplayName,omitempty" tf:"from_display_name,omitempty"`

	// +kubebuilder:validation:Required
	Host *string `json:"host" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	ReplyTo *string `json:"replyTo,omitempty" tf:"reply_to,omitempty"`

	// +kubebuilder:validation:Optional
	ReplyToDisplayName *string `json:"replyToDisplayName,omitempty" tf:"reply_to_display_name,omitempty"`

	// +kubebuilder:validation:Optional
	SSL *bool `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// +kubebuilder:validation:Optional
	Starttls *bool `json:"starttls,omitempty" tf:"starttls,omitempty"`
}

type SecurityDefensesObservation struct {
}

type SecurityDefensesParameters struct {

	// +kubebuilder:validation:Optional
	BruteForceDetection []BruteForceDetectionParameters `json:"bruteForceDetection,omitempty" tf:"brute_force_detection,omitempty"`

	// +kubebuilder:validation:Optional
	Headers []HeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`
}

type WebAuthnPasswordlessPolicyObservation struct {
}

type WebAuthnPasswordlessPolicyParameters struct {

	// +kubebuilder:validation:Optional
	AcceptableAaguids []*string `json:"acceptableAaguids,omitempty" tf:"acceptable_aaguids,omitempty"`

	// Either none, indirect or direct
	// +kubebuilder:validation:Optional
	AttestationConveyancePreference *string `json:"attestationConveyancePreference,omitempty" tf:"attestation_conveyance_preference,omitempty"`

	// Either platform or cross-platform
	// +kubebuilder:validation:Optional
	AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty" tf:"authenticator_attachment,omitempty"`

	// +kubebuilder:validation:Optional
	AvoidSameAuthenticatorRegister *bool `json:"avoidSameAuthenticatorRegister,omitempty" tf:"avoid_same_authenticator_register,omitempty"`

	// +kubebuilder:validation:Optional
	CreateTimeout *float64 `json:"createTimeout,omitempty" tf:"create_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	RelyingPartyEntityName *string `json:"relyingPartyEntityName,omitempty" tf:"relying_party_entity_name,omitempty"`

	// +kubebuilder:validation:Optional
	RelyingPartyID *string `json:"relyingPartyId,omitempty" tf:"relying_party_id,omitempty"`

	// Either Yes or No
	// +kubebuilder:validation:Optional
	RequireResidentKey *string `json:"requireResidentKey,omitempty" tf:"require_resident_key,omitempty"`

	// Keycloak lists ES256, ES384, ES512, RS256, RS384, RS512, RS1 at the time of writing
	// +kubebuilder:validation:Optional
	SignatureAlgorithms []*string `json:"signatureAlgorithms,omitempty" tf:"signature_algorithms,omitempty"`

	// Either required, preferred or discouraged
	// +kubebuilder:validation:Optional
	UserVerificationRequirement *string `json:"userVerificationRequirement,omitempty" tf:"user_verification_requirement,omitempty"`
}

type WebAuthnPolicyObservation struct {
}

type WebAuthnPolicyParameters struct {

	// +kubebuilder:validation:Optional
	AcceptableAaguids []*string `json:"acceptableAaguids,omitempty" tf:"acceptable_aaguids,omitempty"`

	// Either none, indirect or direct
	// +kubebuilder:validation:Optional
	AttestationConveyancePreference *string `json:"attestationConveyancePreference,omitempty" tf:"attestation_conveyance_preference,omitempty"`

	// Either platform or cross-platform
	// +kubebuilder:validation:Optional
	AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty" tf:"authenticator_attachment,omitempty"`

	// +kubebuilder:validation:Optional
	AvoidSameAuthenticatorRegister *bool `json:"avoidSameAuthenticatorRegister,omitempty" tf:"avoid_same_authenticator_register,omitempty"`

	// +kubebuilder:validation:Optional
	CreateTimeout *float64 `json:"createTimeout,omitempty" tf:"create_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	RelyingPartyEntityName *string `json:"relyingPartyEntityName,omitempty" tf:"relying_party_entity_name,omitempty"`

	// +kubebuilder:validation:Optional
	RelyingPartyID *string `json:"relyingPartyId,omitempty" tf:"relying_party_id,omitempty"`

	// Either Yes or No
	// +kubebuilder:validation:Optional
	RequireResidentKey *string `json:"requireResidentKey,omitempty" tf:"require_resident_key,omitempty"`

	// Keycloak lists ES256, ES384, ES512, RS256, RS384, RS512, RS1 at the time of writing
	// +kubebuilder:validation:Optional
	SignatureAlgorithms []*string `json:"signatureAlgorithms,omitempty" tf:"signature_algorithms,omitempty"`

	// Either required, preferred or discouraged
	// +kubebuilder:validation:Optional
	UserVerificationRequirement *string `json:"userVerificationRequirement,omitempty" tf:"user_verification_requirement,omitempty"`
}

// RealmSpec defines the desired state of Realm
type RealmSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RealmParameters `json:"forProvider"`
}

// RealmStatus defines the observed state of Realm.
type RealmStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RealmObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Realm is the Schema for the Realms API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,keycloakjet}
type Realm struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RealmSpec   `json:"spec"`
	Status            RealmStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RealmList contains a list of Realms
type RealmList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Realm `json:"items"`
}

// Repository type metadata.
var (
	Realm_Kind             = "Realm"
	Realm_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Realm_Kind}.String()
	Realm_KindAPIVersion   = Realm_Kind + "." + CRDGroupVersion.String()
	Realm_GroupVersionKind = CRDGroupVersion.WithKind(Realm_Kind)
)

func init() {
	SchemeBuilder.Register(&Realm{}, &RealmList{})
}
