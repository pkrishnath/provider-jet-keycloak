/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type UserAttributeMapperObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type UserAttributeMapperParameters struct {

	// When true, the value fetched from LDAP will override the value stored in Keycloak.
	// +kubebuilder:validation:Optional
	AlwaysReadValueFromLdap *bool `json:"alwaysReadValueFromLdap,omitempty" tf:"always_read_value_from_ldap,omitempty"`

	// When true, this attribute must exist in LDAP.
	// +kubebuilder:validation:Optional
	IsMandatoryInLdap *bool `json:"isMandatoryInLdap,omitempty" tf:"is_mandatory_in_ldap,omitempty"`

	// Name of the mapped attribute on LDAP object.
	// +kubebuilder:validation:Required
	LdapAttribute *string `json:"ldapAttribute" tf:"ldap_attribute,omitempty"`

	// The ldap user federation provider to attach this mapper to.
	// +kubebuilder:validation:Required
	LdapUserFederationID *string `json:"ldapUserFederationId" tf:"ldap_user_federation_id,omitempty"`

	// When true, this attribute is not saved back to LDAP when the user attribute is updated in Keycloak.
	// +kubebuilder:validation:Optional
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`

	// The realm in which the ldap user federation provider exists.
	// +kubebuilder:validation:Required
	RealmID *string `json:"realmId" tf:"realm_id,omitempty"`

	// Name of the UserModel property or attribute you want to map the LDAP attribute into.
	// +kubebuilder:validation:Required
	UserModelAttribute *string `json:"userModelAttribute" tf:"user_model_attribute,omitempty"`
}

// UserAttributeMapperSpec defines the desired state of UserAttributeMapper
type UserAttributeMapperSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     UserAttributeMapperParameters `json:"forProvider"`
}

// UserAttributeMapperStatus defines the observed state of UserAttributeMapper.
type UserAttributeMapperStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        UserAttributeMapperObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// UserAttributeMapper is the Schema for the UserAttributeMappers API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,keycloakjet}
type UserAttributeMapper struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              UserAttributeMapperSpec   `json:"spec"`
	Status            UserAttributeMapperStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// UserAttributeMapperList contains a list of UserAttributeMappers
type UserAttributeMapperList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []UserAttributeMapper `json:"items"`
}

// Repository type metadata.
var (
	UserAttributeMapper_Kind             = "UserAttributeMapper"
	UserAttributeMapper_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: UserAttributeMapper_Kind}.String()
	UserAttributeMapper_KindAPIVersion   = UserAttributeMapper_Kind + "." + CRDGroupVersion.String()
	UserAttributeMapper_GroupVersionKind = CRDGroupVersion.WithKind(UserAttributeMapper_Kind)
)

func init() {
	SchemeBuilder.Register(&UserAttributeMapper{}, &UserAttributeMapperList{})
}
