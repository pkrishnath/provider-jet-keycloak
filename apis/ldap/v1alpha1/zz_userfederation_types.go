/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CacheObservation struct {
}

type CacheParameters struct {

	// Day of the week the entry will become invalid on.
	// +kubebuilder:validation:Optional
	EvictionDay *float64 `json:"evictionDay,omitempty" tf:"eviction_day,omitempty"`

	// Hour of day the entry will become invalid on.
	// +kubebuilder:validation:Optional
	EvictionHour *float64 `json:"evictionHour,omitempty" tf:"eviction_hour,omitempty"`

	// Minute of day the entry will become invalid on.
	// +kubebuilder:validation:Optional
	EvictionMinute *float64 `json:"evictionMinute,omitempty" tf:"eviction_minute,omitempty"`

	// Max lifespan of cache entry (duration string).
	// +kubebuilder:validation:Optional
	MaxLifespan *string `json:"maxLifespan,omitempty" tf:"max_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`
}

type KerberosObservation struct {
}

type KerberosParameters struct {

	// The name of the kerberos realm, e.g. FOO.LOCAL
	// +kubebuilder:validation:Required
	KerberosRealm *string `json:"kerberosRealm" tf:"kerberos_realm,omitempty"`

	// Path to the kerberos keytab file on the server with credentials of the service principal.
	// +kubebuilder:validation:Required
	KeyTab *string `json:"keyTab" tf:"key_tab,omitempty"`

	// The kerberos server principal, e.g. 'HTTP/host.foo.com@FOO.LOCAL'.
	// +kubebuilder:validation:Required
	ServerPrincipal *string `json:"serverPrincipal" tf:"server_principal,omitempty"`

	// Use kerberos login module instead of ldap service api. Defaults to `false`.
	// +kubebuilder:validation:Optional
	UseKerberosForPasswordAuthentication *bool `json:"useKerberosForPasswordAuthentication,omitempty" tf:"use_kerberos_for_password_authentication,omitempty"`
}

type UserFederationObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type UserFederationParameters struct {

	// The number of users to sync within a single transaction.
	// +kubebuilder:validation:Optional
	BatchSizeForSync *float64 `json:"batchSizeForSync,omitempty" tf:"batch_size_for_sync,omitempty"`

	// Password of LDAP admin.
	// +kubebuilder:validation:Optional
	BindCredentialSecretRef *v1.SecretKeySelector `json:"bindCredentialSecretRef,omitempty" tf:"-"`

	// DN of LDAP admin, which will be used by Keycloak to access LDAP server.
	// +kubebuilder:validation:Optional
	BindDn *string `json:"bindDn,omitempty" tf:"bind_dn,omitempty"`

	// Settings regarding cache policy for this realm.
	// +kubebuilder:validation:Optional
	Cache []CacheParameters `json:"cache,omitempty" tf:"cache,omitempty"`

	// How frequently Keycloak should sync changed LDAP users, in seconds. Omit this property to disable periodic changed users sync.
	// +kubebuilder:validation:Optional
	ChangedSyncPeriod *float64 `json:"changedSyncPeriod,omitempty" tf:"changed_sync_period,omitempty"`

	// LDAP connection timeout (duration string)
	// +kubebuilder:validation:Optional
	ConnectionTimeout *string `json:"connectionTimeout,omitempty" tf:"connection_timeout,omitempty"`

	// Connection URL to the LDAP server.
	// +kubebuilder:validation:Required
	ConnectionURL *string `json:"connectionUrl" tf:"connection_url,omitempty"`

	// Additional LDAP filter for filtering searched users. Must begin with '(' and end with ')'.
	// +kubebuilder:validation:Optional
	CustomUserSearchFilter *string `json:"customUserSearchFilter,omitempty" tf:"custom_user_search_filter,omitempty"`

	// READ_ONLY and WRITABLE are self-explanatory. UNSYNCED allows user data to be imported but not synced back to LDAP.
	// +kubebuilder:validation:Optional
	EditMode *string `json:"editMode,omitempty" tf:"edit_mode,omitempty"`

	// When false, this provider will not be used when performing queries for users.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// How frequently Keycloak should sync all LDAP users, in seconds. Omit this property to disable periodic full sync.
	// +kubebuilder:validation:Optional
	FullSyncPeriod *float64 `json:"fullSyncPeriod,omitempty" tf:"full_sync_period,omitempty"`

	// When true, LDAP users will be imported into the Keycloak database.
	// +kubebuilder:validation:Optional
	ImportEnabled *bool `json:"importEnabled,omitempty" tf:"import_enabled,omitempty"`

	// Settings regarding kerberos authentication for this realm.
	// +kubebuilder:validation:Optional
	Kerberos []KerberosParameters `json:"kerberos,omitempty" tf:"kerberos,omitempty"`

	// When true, Keycloak assumes the LDAP server supports pagination.
	// +kubebuilder:validation:Optional
	Pagination *bool `json:"pagination,omitempty" tf:"pagination,omitempty"`

	// Priority of this provider when looking up users. Lower values are first.
	// +kubebuilder:validation:Optional
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// Name of the LDAP attribute to use as the relative distinguished name.
	// +kubebuilder:validation:Required
	RdnLdapAttribute *string `json:"rdnLdapAttribute" tf:"rdn_ldap_attribute,omitempty"`

	// LDAP read timeout (duration string)
	// +kubebuilder:validation:Optional
	ReadTimeout *string `json:"readTimeout,omitempty" tf:"read_timeout,omitempty"`

	// The realm this provider will provide user federation for.
	// +kubebuilder:validation:Required
	RealmID *string `json:"realmId" tf:"realm_id,omitempty"`

	// ONE_LEVEL: only search for users in the DN specified by user_dn. SUBTREE: search entire LDAP subtree.
	// +kubebuilder:validation:Optional
	SearchScope *string `json:"searchScope,omitempty" tf:"search_scope,omitempty"`

	// When true, Keycloak will encrypt the connection to LDAP using STARTTLS, which will disable connection pooling.
	// +kubebuilder:validation:Optional
	StartTLS *bool `json:"startTls,omitempty" tf:"start_tls,omitempty"`

	// When true, newly created users will be synced back to LDAP.
	// +kubebuilder:validation:Optional
	SyncRegistrations *bool `json:"syncRegistrations,omitempty" tf:"sync_registrations,omitempty"`

	// If enabled, email provided by this provider is not verified even if verification is enabled for the realm.
	// +kubebuilder:validation:Optional
	TrustEmail *bool `json:"trustEmail,omitempty" tf:"trust_email,omitempty"`

	// Name of the LDAP attribute to use as a unique object identifier for objects in LDAP.
	// +kubebuilder:validation:Required
	UUIDLdapAttribute *string `json:"uuidLdapAttribute" tf:"uuid_ldap_attribute,omitempty"`

	// When `true`, use the LDAPv3 Password Modify Extended Operation (RFC-3062).
	// +kubebuilder:validation:Optional
	UsePasswordModifyExtendedOp *bool `json:"usePasswordModifyExtendedOp,omitempty" tf:"use_password_modify_extended_op,omitempty"`

	// +kubebuilder:validation:Optional
	UseTruststoreSpi *string `json:"useTruststoreSpi,omitempty" tf:"use_truststore_spi,omitempty"`

	// All values of LDAP objectClass attribute for users in LDAP.
	// +kubebuilder:validation:Required
	UserObjectClasses []*string `json:"userObjectClasses" tf:"user_object_classes,omitempty"`

	// Name of the LDAP attribute to use as the Keycloak username.
	// +kubebuilder:validation:Required
	UsernameLdapAttribute *string `json:"usernameLdapAttribute" tf:"username_ldap_attribute,omitempty"`

	// Full DN of LDAP tree where your users are.
	// +kubebuilder:validation:Required
	UsersDn *string `json:"usersDn" tf:"users_dn,omitempty"`

	// When true, Keycloak will validate passwords using the realm policy before updating it.
	// +kubebuilder:validation:Optional
	ValidatePasswordPolicy *bool `json:"validatePasswordPolicy,omitempty" tf:"validate_password_policy,omitempty"`

	// LDAP vendor. I am almost certain this field does nothing, but the UI indicates that it is required.
	// +kubebuilder:validation:Optional
	Vendor *string `json:"vendor,omitempty" tf:"vendor,omitempty"`
}

// UserFederationSpec defines the desired state of UserFederation
type UserFederationSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     UserFederationParameters `json:"forProvider"`
}

// UserFederationStatus defines the observed state of UserFederation.
type UserFederationStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        UserFederationObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// UserFederation is the Schema for the UserFederations API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,keycloakjet}
type UserFederation struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              UserFederationSpec   `json:"spec"`
	Status            UserFederationStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// UserFederationList contains a list of UserFederations
type UserFederationList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []UserFederation `json:"items"`
}

// Repository type metadata.
var (
	UserFederation_Kind             = "UserFederation"
	UserFederation_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: UserFederation_Kind}.String()
	UserFederation_KindAPIVersion   = UserFederation_Kind + "." + CRDGroupVersion.String()
	UserFederation_GroupVersionKind = CRDGroupVersion.WithKind(UserFederation_Kind)
)

func init() {
	SchemeBuilder.Register(&UserFederation{}, &UserFederationList{})
}
