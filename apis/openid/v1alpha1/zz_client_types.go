/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AuthenticationFlowBindingOverridesObservation struct {
}

type AuthenticationFlowBindingOverridesParameters struct {

	// +kubebuilder:validation:Optional
	BrowserID *string `json:"browserId,omitempty" tf:"browser_id,omitempty"`

	// +kubebuilder:validation:Optional
	DirectGrantID *string `json:"directGrantId,omitempty" tf:"direct_grant_id,omitempty"`
}

type AuthorizationObservation struct {
}

type AuthorizationParameters struct {

	// +kubebuilder:validation:Optional
	AllowRemoteResourceManagement *bool `json:"allowRemoteResourceManagement,omitempty" tf:"allow_remote_resource_management,omitempty"`

	// +kubebuilder:validation:Optional
	DecisionStrategy *string `json:"decisionStrategy,omitempty" tf:"decision_strategy,omitempty"`

	// +kubebuilder:validation:Optional
	KeepDefaults *bool `json:"keepDefaults,omitempty" tf:"keep_defaults,omitempty"`

	// +kubebuilder:validation:Required
	PolicyEnforcementMode *string `json:"policyEnforcementMode" tf:"policy_enforcement_mode,omitempty"`
}

type ClientObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	ResourceServerID *string `json:"resourceServerId,omitempty" tf:"resource_server_id,omitempty"`

	ServiceAccountUserID *string `json:"serviceAccountUserId,omitempty" tf:"service_account_user_id,omitempty"`
}

type ClientParameters struct {

	// +kubebuilder:validation:Optional
	AccessTokenLifespan *string `json:"accessTokenLifespan,omitempty" tf:"access_token_lifespan,omitempty"`

	// +kubebuilder:validation:Required
	AccessType *string `json:"accessType" tf:"access_type,omitempty"`

	// +kubebuilder:validation:Optional
	AdminURL *string `json:"adminUrl,omitempty" tf:"admin_url,omitempty"`

	// +kubebuilder:validation:Optional
	AuthenticationFlowBindingOverrides []AuthenticationFlowBindingOverridesParameters `json:"authenticationFlowBindingOverrides,omitempty" tf:"authentication_flow_binding_overrides,omitempty"`

	// +kubebuilder:validation:Optional
	Authorization []AuthorizationParameters `json:"authorization,omitempty" tf:"authorization,omitempty"`

	// +kubebuilder:validation:Optional
	BackchannelLogoutRevokeOfflineSessions *bool `json:"backchannelLogoutRevokeOfflineSessions,omitempty" tf:"backchannel_logout_revoke_offline_sessions,omitempty"`

	// +kubebuilder:validation:Optional
	BackchannelLogoutSessionRequired *bool `json:"backchannelLogoutSessionRequired,omitempty" tf:"backchannel_logout_session_required,omitempty"`

	// +kubebuilder:validation:Optional
	BackchannelLogoutURL *string `json:"backchannelLogoutUrl,omitempty" tf:"backchannel_logout_url,omitempty"`

	// +kubebuilder:validation:Optional
	BaseURL *string `json:"baseUrl,omitempty" tf:"base_url,omitempty"`

	// +kubebuilder:validation:Optional
	ClientAuthenticatorType *string `json:"clientAuthenticatorType,omitempty" tf:"client_authenticator_type,omitempty"`

	// +kubebuilder:validation:Required
	ClientID *string `json:"clientId" tf:"client_id,omitempty"`

	// +kubebuilder:validation:Optional
	ClientOfflineSessionIdleTimeout *string `json:"clientOfflineSessionIdleTimeout,omitempty" tf:"client_offline_session_idle_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	ClientOfflineSessionMaxLifespan *string `json:"clientOfflineSessionMaxLifespan,omitempty" tf:"client_offline_session_max_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	ClientSecretSecretRef *v1.SecretKeySelector `json:"clientSecretSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ClientSessionIdleTimeout *string `json:"clientSessionIdleTimeout,omitempty" tf:"client_session_idle_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	ClientSessionMaxLifespan *string `json:"clientSessionMaxLifespan,omitempty" tf:"client_session_max_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	ConsentRequired *bool `json:"consentRequired,omitempty" tf:"consent_required,omitempty"`

	// +kubebuilder:validation:Optional
	ConsentScreenText *string `json:"consentScreenText,omitempty" tf:"consent_screen_text,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DirectAccessGrantsEnabled *bool `json:"directAccessGrantsEnabled,omitempty" tf:"direct_access_grants_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	DisplayOnConsentScreen *bool `json:"displayOnConsentScreen,omitempty" tf:"display_on_consent_screen,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	ExcludeSessionStateFromAuthResponse *bool `json:"excludeSessionStateFromAuthResponse,omitempty" tf:"exclude_session_state_from_auth_response,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraConfig map[string]*string `json:"extraConfig,omitempty" tf:"extra_config,omitempty"`

	// +kubebuilder:validation:Optional
	FrontchannelLogoutEnabled *bool `json:"frontchannelLogoutEnabled,omitempty" tf:"frontchannel_logout_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	FrontchannelLogoutURL *string `json:"frontchannelLogoutUrl,omitempty" tf:"frontchannel_logout_url,omitempty"`

	// +kubebuilder:validation:Optional
	FullScopeAllowed *bool `json:"fullScopeAllowed,omitempty" tf:"full_scope_allowed,omitempty"`

	// +kubebuilder:validation:Optional
	ImplicitFlowEnabled *bool `json:"implicitFlowEnabled,omitempty" tf:"implicit_flow_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	LoginTheme *string `json:"loginTheme,omitempty" tf:"login_theme,omitempty"`

	// +kubebuilder:validation:Optional
	Oauth2DeviceAuthorizationGrantEnabled *bool `json:"oauth2DeviceAuthorizationGrantEnabled,omitempty" tf:"oauth2_device_authorization_grant_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	Oauth2DeviceCodeLifespan *string `json:"oauth2DeviceCodeLifespan,omitempty" tf:"oauth2_device_code_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	Oauth2DevicePollingInterval *string `json:"oauth2DevicePollingInterval,omitempty" tf:"oauth2_device_polling_interval,omitempty"`

	// +kubebuilder:validation:Optional
	PkceCodeChallengeMethod *string `json:"pkceCodeChallengeMethod,omitempty" tf:"pkce_code_challenge_method,omitempty"`

	// +kubebuilder:validation:Required
	RealmID *string `json:"realmId" tf:"realm_id,omitempty"`

	// +kubebuilder:validation:Optional
	RootURL *string `json:"rootUrl,omitempty" tf:"root_url,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceAccountsEnabled *bool `json:"serviceAccountsEnabled,omitempty" tf:"service_accounts_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	StandardFlowEnabled *bool `json:"standardFlowEnabled,omitempty" tf:"standard_flow_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	UseRefreshTokens *bool `json:"useRefreshTokens,omitempty" tf:"use_refresh_tokens,omitempty"`

	// +kubebuilder:validation:Optional
	UseRefreshTokensClientCredentials *bool `json:"useRefreshTokensClientCredentials,omitempty" tf:"use_refresh_tokens_client_credentials,omitempty"`

	// +kubebuilder:validation:Optional
	ValidRedirectUris []*string `json:"validRedirectUris,omitempty" tf:"valid_redirect_uris,omitempty"`

	// +kubebuilder:validation:Optional
	WebOrigins []*string `json:"webOrigins,omitempty" tf:"web_origins,omitempty"`
}

// ClientSpec defines the desired state of Client
type ClientSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClientParameters `json:"forProvider"`
}

// ClientStatus defines the observed state of Client.
type ClientStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClientObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Client is the Schema for the Clients API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,keycloakjet}
type Client struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClientSpec   `json:"spec"`
	Status            ClientStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClientList contains a list of Clients
type ClientList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Client `json:"items"`
}

// Repository type metadata.
var (
	Client_Kind             = "Client"
	Client_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Client_Kind}.String()
	Client_KindAPIVersion   = Client_Kind + "." + CRDGroupVersion.String()
	Client_GroupVersionKind = CRDGroupVersion.WithKind(Client_Kind)
)

func init() {
	SchemeBuilder.Register(&Client{}, &ClientList{})
}
