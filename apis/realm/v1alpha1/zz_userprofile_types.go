/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AttributeObservation struct {
}

type AttributeParameters struct {

	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// +kubebuilder:validation:Optional
	EnabledWhenScope []*string `json:"enabledWhenScope,omitempty" tf:"enabled_when_scope,omitempty"`

	// +kubebuilder:validation:Optional
	Group *string `json:"group,omitempty" tf:"group,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Permissions []PermissionsParameters `json:"permissions,omitempty" tf:"permissions,omitempty"`

	// +kubebuilder:validation:Optional
	RequiredForRoles []*string `json:"requiredForRoles,omitempty" tf:"required_for_roles,omitempty"`

	// +kubebuilder:validation:Optional
	RequiredForScopes []*string `json:"requiredForScopes,omitempty" tf:"required_for_scopes,omitempty"`

	// +kubebuilder:validation:Optional
	Validator []ValidatorParameters `json:"validator,omitempty" tf:"validator,omitempty"`
}

type GroupObservation struct {
}

type GroupParameters struct {

	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// +kubebuilder:validation:Optional
	DisplayDescription *string `json:"displayDescription,omitempty" tf:"display_description,omitempty"`

	// +kubebuilder:validation:Optional
	DisplayHeader *string `json:"displayHeader,omitempty" tf:"display_header,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type PermissionsObservation struct {
}

type PermissionsParameters struct {

	// +kubebuilder:validation:Required
	Edit []*string `json:"edit" tf:"edit,omitempty"`

	// +kubebuilder:validation:Required
	View []*string `json:"view" tf:"view,omitempty"`
}

type UserProfileObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type UserProfileParameters struct {

	// +kubebuilder:validation:Optional
	Attribute []AttributeParameters `json:"attribute,omitempty" tf:"attribute,omitempty"`

	// +kubebuilder:validation:Optional
	Group []GroupParameters `json:"group,omitempty" tf:"group,omitempty"`

	// +kubebuilder:validation:Required
	RealmID *string `json:"realmId" tf:"realm_id,omitempty"`
}

type ValidatorObservation struct {
}

type ValidatorParameters struct {

	// +kubebuilder:validation:Optional
	Config map[string]*string `json:"config,omitempty" tf:"config,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

// UserProfileSpec defines the desired state of UserProfile
type UserProfileSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     UserProfileParameters `json:"forProvider"`
}

// UserProfileStatus defines the observed state of UserProfile.
type UserProfileStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        UserProfileObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// UserProfile is the Schema for the UserProfiles API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,keycloakjet}
type UserProfile struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              UserProfileSpec   `json:"spec"`
	Status            UserProfileStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// UserProfileList contains a list of UserProfiles
type UserProfileList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []UserProfile `json:"items"`
}

// Repository type metadata.
var (
	UserProfile_Kind             = "UserProfile"
	UserProfile_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: UserProfile_Kind}.String()
	UserProfile_KindAPIVersion   = UserProfile_Kind + "." + CRDGroupVersion.String()
	UserProfile_GroupVersionKind = CRDGroupVersion.WithKind(UserProfile_Kind)
)

func init() {
	SchemeBuilder.Register(&UserProfile{}, &UserProfileList{})
}
