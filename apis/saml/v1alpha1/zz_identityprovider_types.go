/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type IdentityProviderObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	InternalID *string `json:"internalId,omitempty" tf:"internal_id,omitempty"`
}

type IdentityProviderParameters struct {

	// Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.
	// +kubebuilder:validation:Optional
	AddReadTokenRoleOnCreate *bool `json:"addReadTokenRoleOnCreate,omitempty" tf:"add_read_token_role_on_create,omitempty"`

	// The alias uniquely identifies an identity provider and it is also used to build the redirect uri.
	// +kubebuilder:validation:Required
	Alias *string `json:"alias" tf:"alias,omitempty"`

	// Enable/disable authenticate users by default.
	// +kubebuilder:validation:Optional
	AuthenticateByDefault *bool `json:"authenticateByDefault,omitempty" tf:"authenticate_by_default,omitempty"`

	// Does the external IDP support backchannel logout?
	// +kubebuilder:validation:Optional
	BackchannelSupported *bool `json:"backchannelSupported,omitempty" tf:"backchannel_supported,omitempty"`

	// Friendly name for Identity Providers.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Enable/disable this identity provider.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The Entity ID that will be used to uniquely identify this SAML Service Provider.
	// +kubebuilder:validation:Required
	EntityID *string `json:"entityId" tf:"entity_id,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraConfig map[string]*string `json:"extraConfig,omitempty" tf:"extra_config,omitempty"`

	// Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account.
	// +kubebuilder:validation:Optional
	FirstBrokerLoginFlowAlias *string `json:"firstBrokerLoginFlowAlias,omitempty" tf:"first_broker_login_flow_alias,omitempty"`

	// Require Force Authn.
	// +kubebuilder:validation:Optional
	ForceAuthn *bool `json:"forceAuthn,omitempty" tf:"force_authn,omitempty"`

	// GUI Order
	// +kubebuilder:validation:Optional
	GuiOrder *string `json:"guiOrder,omitempty" tf:"gui_order,omitempty"`

	// Hide On Login Page.
	// +kubebuilder:validation:Optional
	HideOnLoginPage *bool `json:"hideOnLoginPage,omitempty" tf:"hide_on_login_page,omitempty"`

	// If true, users cannot log in through this provider.  They can only link to this provider.  This is useful if you don't want to allow login from the provider, but want to integrate with a provider
	// +kubebuilder:validation:Optional
	LinkOnly *bool `json:"linkOnly,omitempty" tf:"link_only,omitempty"`

	// Name ID Policy Format.
	// +kubebuilder:validation:Optional
	NameIDPolicyFormat *string `json:"nameIdPolicyFormat,omitempty" tf:"name_id_policy_format,omitempty"`

	// Post Binding Authn Request.
	// +kubebuilder:validation:Optional
	PostBindingAuthnRequest *bool `json:"postBindingAuthnRequest,omitempty" tf:"post_binding_authn_request,omitempty"`

	// Post Binding Logout.
	// +kubebuilder:validation:Optional
	PostBindingLogout *bool `json:"postBindingLogout,omitempty" tf:"post_binding_logout,omitempty"`

	// Post Binding Response.
	// +kubebuilder:validation:Optional
	PostBindingResponse *bool `json:"postBindingResponse,omitempty" tf:"post_binding_response,omitempty"`

	// Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it.
	// +kubebuilder:validation:Optional
	PostBrokerLoginFlowAlias *string `json:"postBrokerLoginFlowAlias,omitempty" tf:"post_broker_login_flow_alias,omitempty"`

	// Principal Attribute
	// +kubebuilder:validation:Optional
	PrincipalAttribute *string `json:"principalAttribute,omitempty" tf:"principal_attribute,omitempty"`

	// Principal Type
	// +kubebuilder:validation:Optional
	PrincipalType *string `json:"principalType,omitempty" tf:"principal_type,omitempty"`

	// provider id, is always saml, unless you have a custom implementation
	// +kubebuilder:validation:Optional
	ProviderID *string `json:"providerId,omitempty" tf:"provider_id,omitempty"`

	// Realm Name
	// +kubebuilder:validation:Required
	Realm *string `json:"realm" tf:"realm,omitempty"`

	// Signing Algorithm.
	// +kubebuilder:validation:Optional
	SignatureAlgorithm *string `json:"signatureAlgorithm,omitempty" tf:"signature_algorithm,omitempty"`

	// Signing Certificate.
	// +kubebuilder:validation:Optional
	SigningCertificate *string `json:"signingCertificate,omitempty" tf:"signing_certificate,omitempty"`

	// Logout URL.
	// +kubebuilder:validation:Optional
	SingleLogoutServiceURL *string `json:"singleLogoutServiceUrl,omitempty" tf:"single_logout_service_url,omitempty"`

	// SSO Logout URL.
	// +kubebuilder:validation:Required
	SingleSignOnServiceURL *string `json:"singleSignOnServiceUrl" tf:"single_sign_on_service_url,omitempty"`

	// Enable/disable if tokens must be stored after authenticating users.
	// +kubebuilder:validation:Optional
	StoreToken *bool `json:"storeToken,omitempty" tf:"store_token,omitempty"`

	// Sync Mode
	// +kubebuilder:validation:Optional
	SyncMode *string `json:"syncMode,omitempty" tf:"sync_mode,omitempty"`

	// If enabled then email provided by this provider is not verified even if verification is enabled for the realm.
	// +kubebuilder:validation:Optional
	TrustEmail *bool `json:"trustEmail,omitempty" tf:"trust_email,omitempty"`

	// Enable/disable signature validation of SAML responses.
	// +kubebuilder:validation:Optional
	ValidateSignature *bool `json:"validateSignature,omitempty" tf:"validate_signature,omitempty"`

	// Want Assertions Encrypted.
	// +kubebuilder:validation:Optional
	WantAssertionsEncrypted *bool `json:"wantAssertionsEncrypted,omitempty" tf:"want_assertions_encrypted,omitempty"`

	// Want Assertions Signed.
	// +kubebuilder:validation:Optional
	WantAssertionsSigned *bool `json:"wantAssertionsSigned,omitempty" tf:"want_assertions_signed,omitempty"`

	// Sign Key Transformer.
	// +kubebuilder:validation:Optional
	XMLSignKeyInfoKeyNameTransformer *string `json:"xmlSignKeyInfoKeyNameTransformer,omitempty" tf:"xml_sign_key_info_key_name_transformer,omitempty"`
}

// IdentityProviderSpec defines the desired state of IdentityProvider
type IdentityProviderSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     IdentityProviderParameters `json:"forProvider"`
}

// IdentityProviderStatus defines the observed state of IdentityProvider.
type IdentityProviderStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        IdentityProviderObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// IdentityProvider is the Schema for the IdentityProviders API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,keycloakjet}
type IdentityProvider struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              IdentityProviderSpec   `json:"spec"`
	Status            IdentityProviderStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// IdentityProviderList contains a list of IdentityProviders
type IdentityProviderList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []IdentityProvider `json:"items"`
}

// Repository type metadata.
var (
	IdentityProvider_Kind             = "IdentityProvider"
	IdentityProvider_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: IdentityProvider_Kind}.String()
	IdentityProvider_KindAPIVersion   = IdentityProvider_Kind + "." + CRDGroupVersion.String()
	IdentityProvider_GroupVersionKind = CRDGroupVersion.WithKind(IdentityProvider_Kind)
)

func init() {
	SchemeBuilder.Register(&IdentityProvider{}, &IdentityProviderList{})
}
